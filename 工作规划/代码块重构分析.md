# _**代码块重构分析:**_

# 目的（原因）:
* 代码块单步存储，保存所有数据交互数据量比较大（非必要）
* 代码块数据存储 数据较大
* 代码块参数替换部分接口混乱
* event 接口类型混乱
* expr  数据类型太多不变管理
* statement 结构过于复杂混乱
* 代码块运行节点重构 
* 代码块时间线（device）重构
* 代码块函数重构
* 支持代码块 信息查询 （模糊查询）

## 风险项 及 影响面：
* 正常代码块运行
* 函数正常运行
* 时间线
* 变量
* 列表（数组）
* 代码块 运行状态展示
* 使用和打包 实体模板的代码块数据
* 领地 和 GOB 中的实体代码块数据
* 老数据兼容处理
* 老数据  转换为 新的代码块数据 


## 正确性怎么保证：
* 所有代码块全部运行一遍
* 老数据 对应的代码块 数据解析（翻译）校正
* 随机模板地图测试正常性
* 所有课程 全部检查测试一次

------

## pb数据结构模型：
* ProgramOld || CodeBlockPrograms   -> codePrograms
    * codeTag1
        * block_1
        * block_2
        * ......
        * block_N

    * codeTag2

------

 ## 详细开发任务： 
 * 代码块交互数据结构：
    * 代码块参数结构 <1day>    
    * 代码块数据结构 <1day>
    * 代码块标签页结构<0.5day>
    * 函数数据结构<0.5day> 
    * 时间线数据结构<1day>
    * 变量 列表 相关结构<0.5day>
    * 代码块标签页数据结构<0.5day>
    * 实体所有代码块的主体据结构<0.3day>

* 代码交换协议：
    * 代码块数据获取交互接口 <0.3>
    * （代码块/函数） 添加 删除 更新 交互接口（最小颗粒为一个作用域）<0.3>
    * 时间线 交互接口调整（最小消息颗粒 时间轨）<0.3>
    * 变量  列表 （检查||修改）<0.5>
    


* 代码块运行相关：
    * 代码块配置数据导入<1.0>
    * 代码块节点 node 生成与解析  <注意预留 模糊查询接口><3.0>    
    * 代码块作用域 生成与解析（需要运行的节点 和 查询的节点）<3.0>
    * 代码块作用域 解析生成运行节点<3>
    * 代码块作用域 节点运行<3>
    * 代码块作用域 节点跳转(同步考虑函数和时间线的跳转)<3>
    * 代码块运行参数获取<2>
    * 代码块节点运行结果处理<1>
    * 代码块返回值<1>
    * 代码块作用域 运行状态处理  <1>
    * 实体作用域代码块的动态更新 <2>
    * 变量(创建，更新， 删除)<3>
    * 变量运行数据处理<2> 
    * 列表(创建，更新， 删除)<3>
    * 列表运行数据处理<2>
    * 函数代码块 节点解析<3>
    * 函数代码块 调用和运行<3>
    * 函数代码块 运行节点跳转<2>
    * 函数代码块 返回值处理（返回值尽量做出统一接口）<1>
    * 时间线 解析<3>
    * 时间轨 运行节点解析<2>
    * 时间线 调用和运行<3>
    * 时间线 运行节点跳转<2>
    * 时间线 动态更新<2>
   

* 代码块数据存储：
    * 实体代码块数据存储 （Mysql, seqlite, gob）<1>
    * 实体代码块数据LOAD （Mysql, seqlite, gob）<1>
    * 实体模板中的代码块数据处理<3>
    * 代码块模板数据处理<3>
    * 老数据结构  和 新数据结构的转换（服务器专属）<3>
    * 老数据结构和新数据结构的转换详细测试<3>
     




------



 ## 数据模型：
    scope{ 
        id:v1
        
        block 
        {
            id
            cfgID
            ary[]
            {
                index:
                argDaga
                {
                    blickID : 
                    
                    num'
                    string
                    bool
                }
            }

            nextBlock:block

            branch:block[];
        }

    block{

    }
        value: blockId[]

    }

    [o][][][][][][][o]
