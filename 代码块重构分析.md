# _**代码块重构分析:**_

# 目的（原因）:
* 代码块单步存储，保存所有数据交互数据量比较大（非必要）
* 代码块数据存储 数据较大
* 代码块参数替换部分接口混乱
* event 接口类型混乱
* expr  数据类型太多不变管理
* statement 结构过于复杂混乱
* 代码块运行节点重构 
* 代码块时间线（device）重构
* 代码块函数重构
* 支持代码块 信息查询 （模糊查询）

## 风险项 及 影响面：
* 正常代码块运行
* 函数正常运行
* 时间线
* 变量
* 列表（数组）
* 代码块 运行状态展示
* 使用和打包 实体模板的代码块数据
* 领地 和 GOB 中的实体代码块数据
* 老数据兼容处理
* 老数据  转换为 新的代码块数据 


## 正确性怎么保证：
* 所有代码块全部运行一遍
* 老数据 对应的代码块 数据解析（翻译）校正
* 随机模板地图测试正常性
* 所有课程 全部检查测试一次

------

## pb数据结构模型：
* ProgramOld || CodeBlockPrograms   -> codePrograms
    * codeTag1
        * block_1
        * block_2
        * ......
        * block_N

    * codeTag2

------

 ## 详细开发任务： 
 * 代码块交换数据结构：
    * 代码块数据结构
    * 代码块参数数据结构
    * 函数数据结构
    * 时间线数据结构
    * 变量 列表 相关结构
    * 代码块标签页数据结构
    * 实体所有代码块的总数据结构

* 代码交换协议：
    * 代码块数据获取交互接口
    * （代码块/函数） 添加 删除 更新 交互接口（最小颗粒为一个作用域）
    * 时间线 交互接口调整（最小消息颗粒 时间轨）
    * 变量  列表 （检查||修改）
    


* 代码块运行相关：
    * 代码块配置数据导入
    * 代码块节点 node 生成与解析  <注意预留 模糊查询接口>
    * 代码块节点运行结果处理
    * 代码块运行参数获取
    * 代码块返回值
    * 代码块作用域 生成与解析（需要运行的节点 和 查询的节点）
    * 代码块作用域 解析生成运行节点
    * 代码块作用域 节点运行接口
    * 代码块作用域 节点跳转(同步考虑函数和时间线的跳转)
    * 代码块作用域 运行状态处理
    * 实体作用域代码块的动态更新
    * 函数代码块 节点解析
    * 函数代码块 调用和运行
    * 函数代码块 运行节点跳转
    * 函数代码块 返回值处理（返回值尽量做出统一接口）
    * 时间线 解析
    * 时间轨 运行节点解析
    * 时间线 调用和运行
    * 时间线 运行节点跳转
    * 时间线 动态更新
    * 变量(创建，更新， 删除)
    * 变量运行数据处理 
    * 列表(创建，更新， 删除)
    * 列表运行数据处理

* 代码块数据存储：
    * 实体代码块数据存储 （Mysql, seqlite, gob）
    * 实体代码块数据LOAD （Mysql, seqlite, gob）
    * 实体模板中的代码块数据处理
    * 代码块模板数据处理
    * 老数据结构  和 新数据结构的转换（服务器专属）




------



 ## 数据模型：
    scope{ 
        id:v1
        
        block 
        {
            id
            cfgID
            ary[]
            {
                index:
                argDaga
                {
                    blickID : 
                    
                    num'
                    string
                    bool
                }
            }

            nextBlock:block

            branch:block[];
        }

    block{

    }
        value: blockId[]

    }

    [o][][][][][][][o]


block{
    cid  
    args :{
        pram{
            int bool  == 1
            
            block{
                block{
                    int a = 1;
                }
            }
        }

    } 


}

node{
    cid,
    args:
    return:
    next-> 


}